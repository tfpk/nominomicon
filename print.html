<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Nom Guide (Nominomicon)</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> The Nom Way</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Tags and Character Classes</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Alternatives and Composition</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Custom Outputs from Functions</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Repeating with Predicates</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Repeating Parsers</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> Using Errors from Outside Nom</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">8.</strong> Streaming vs. Complete</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">9.</strong> Characters vs. Bytes</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">10.</strong> Exercises and Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Nom Guide (Nominomicon)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-nominomicon"><a class="header" href="#the-nominomicon">The Nominomicon</a></h1>
<p>Welcome to Nominomicon; a guide to using the Nom parser for great good.
This guide will give you an introduction to the theory and practice of 
using Nom.</p>
<p>This guide assumes only that you are:</p>
<ul>
<li>Wanting to learn Nom,</li>
<li>Already familiar with Rust.</li>
</ul>
<p>Nom is a parser-combinator library. In other words, it gives you tools to define:</p>
<ul>
<li>&quot;parsers&quot; (a function that takes an input, and gives back an output), and</li>
<li>&quot;combinators&quot; (functions that take parsers, and <em>combine</em> them together!).</li>
</ul>
<p>By combining parsers with combinators, you can build complex parsers up from
simpler ones. These complex parsers are enough to understand HTML, mkv or Python!</p>
<p>Before we set off, it's important to list some caveats:</p>
<ul>
<li>This guide is for Nom7. Nom has undergone significant changes, so if
you are searching for documentation or StackOverflow answers, you may
find older documentation. Some common indicators that it is an old version are:
<ul>
<li>Documentation older than 21st August, 2021</li>
<li>Use of the <code>named!</code> macro</li>
<li>Use of <code>CompleteStr</code> or <code>CompleteByteArray</code>.</li>
</ul>
</li>
<li>Nom can parse (almost) anything; but this guide will focus almost entirely on parsing
complete <code>&amp;str</code> into things.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-the-nom-way"><a class="header" href="#chapter-1-the-nom-way">Chapter 1: The Nom Way</a></h1>
<p>First of all, we need to understand the way that nom thinks about parsing.
As discussed in the introduction, nom lets us build simple parsers, and
then combine them (using &quot;combinators&quot;).</p>
<p>Let's discuss what a &quot;parser&quot; actually does. A parser takes an input and returns
a result, where:</p>
<ul>
<li><code>Ok</code> indicates the parser successfully found what it was looking for; or</li>
<li><code>Err</code> indicates the parser could not find what it was looking for.</li>
</ul>
<p>If the parser was successful, then it will return a tuple. The first field of the
tuple will contain everything the parser did not process. The second will contain
everything the parser processed. The idea is that a parser can happily parse the first
<em>part</em> of an input, without being able to parse the whole thing.</p>
<p>If the parser failed, then there are multiple errors that could be returned.
For simplicity, however, in the next chapters we will leave these unexplored.</p>
<pre><code class="language-text">                                   ┌─► Ok(
                                   │      what the parser didn't touch,
                                   │      what matched the regex
                                   │   )
             ┌─────────┐           │
 my input───►│my parser├──►either──┤
             └─────────┘           └─► Err(...)
</code></pre>
<p>To represent this model of the world, nom uses the <code>IResult&lt;I, O&gt;</code> type.
The <code>Ok</code> variant takes two types -- <code>I</code>, the type of the input; and <code>O</code>, the type
of the output, whereas the <code>Err</code> variant stores an error.</p>
<p>You can import that from:</p>
<pre><code class="language-rust ignore">use nom::IResult;
</code></pre>
<p>You'll note that <code>I</code> and <code>O</code> are parameterized -- while most of the examples in this book
will be with <code>&amp;str</code> (i.e. parsing a string); they do not have to be strings; nor do they
have to be the same type (consider the simple example where <code>I = &amp;str</code>, and <code>O = u64</code> -- this
parses a string into an unsigned integer).</p>
<p>Let's write our first parser!
The simplest parser we can write is one which successfully does nothing.</p>
<p>This parser should take in an <code>&amp;str</code>:</p>
<ul>
<li>Since it is supposed to succeed, we know it will return the Ok Variant.</li>
<li>Since it does nothing to our input, the remaining input is the same as the input.</li>
<li>Since it doesn't parse anything, it also should just return an empty string.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use nom::IResult;
</span><span class="boring">use std::error::Error;
</span>
pub fn do_nothing_parser(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {
    Ok((input, &quot;&quot;))
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let (remaining_input, output) = do_nothing_parser(&quot;my_input&quot;)?;
    assert_eq!(remaining_input, &quot;my_input&quot;);
    assert_eq!(output, &quot;&quot;);
<span class="boring">  Ok(())
</span>}
</code></pre></pre>
<p>It's that easy!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-tags-and-character-classes"><a class="header" href="#chapter-2-tags-and-character-classes">Chapter 2: Tags and Character Classes</a></h1>
<p>The simplest <em>useful</em> parser you can write is one which
has no special characters, it just matches a string.</p>
<p>In <code>nom</code>, we call a simple collection of bytes a tag. Because
these are so common, there already exists a function called <code>tag()</code>.
This function returns a parser for a given string.</p>
<p><strong>Warning</strong>: <code>nom</code> has multiple different definitions of <code>tag</code>, make sure you use this one for the
moment!</p>
<pre><code class="language-rust ignore"><span class="boring">extern crate nom;
</span>pub use nom::bytes::complete::tag;
</code></pre>
<p>For example, code to parse the string <code>&quot;abc&quot;</code> could be represented as <code>tag(&quot;abc&quot;)</code>.</p>
<p>If you have not programmed in a language where functions are values, the type signature of them
tag function might be a surprise:</p>
<pre><code class="language-rust ignore">pub fn tag&lt;T, Input, Error: ParseError&lt;Input&gt;&gt;(
    tag: T
) -&gt; impl Fn(Input) -&gt; IResult&lt;Input, Input, Error&gt; where
    Input: InputTake + Compare&lt;T&gt;,
    T: InputLength + Clone, 
</code></pre>
<p>Or, for the case where <code>Input</code> and <code>T</code> are both <code>&amp;str</code>, and simplifying slightly:</p>
<pre><code class="language-rust ignore">fn tag(tag: &amp;str) -&gt; (impl Fn(&amp;str) -&gt; IResult&lt;&amp;str, Error&gt;)
</code></pre>
<p>In other words, this function <code>tag</code> <em>returns a function</em>. The function it returns is a
parser, taking a <code>&amp;str</code> and returning an <code>IResult</code>. Functions creating parsers and 
returning them is a common pattern in Nom, so it is useful to call out.</p>
<p>Below, we have implemented a function that uses <code>tag</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate nom;
</span><span class="boring">pub use nom::bytes::complete::tag;
</span><span class="boring">pub use nom::IResult;
</span><span class="boring">use std::error::Error;
</span>
fn parse_input(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {
    //  note that this is really creating a function, the parser for abc
    //  vvvvv 
    //         which is then called here, returning an IResult&lt;&amp;str, &amp;str&gt;
    //         vvvvv
    tag(&quot;abc&quot;)(input)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let (leftover_input, output) = parse_input(&quot;abcWorld&quot;)?;
    assert_eq!(leftover_input, &quot;World&quot;);
    assert_eq!(output, &quot;abc&quot;);

    assert!(parse_input(&quot;defWorld&quot;).is_err());
<span class="boring">  Ok(())
</span>}
</code></pre></pre>
<p>If you'd like to, you can also check tags without case-sensitivity
with the <a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.tag_no_case.html"><code>tag_no_case</code></a> function.</p>
<h2 id="character-classes"><a class="header" href="#character-classes">Character Classes</a></h2>
<p>Tags are incredibly useful, but they are also incredibly restrictive.
The other end of Nom's functionality is pre-written parsers that allow us to accept any of a group of characters,
rather than just accepting characters in a defined sequence.</p>
<p>Here is a selection of them:</p>
<ul>
<li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.alpha0.html"><code>alpha0</code></a>: Recognizes zero or more lowercase and uppercase alphabetic characters: <code>/[a-zA-Z]/</code>. <a href="https://docs.rs/nom/latest/nom/character/complete/fn.alpha1.html"><code>alpha1</code></a> does the same but returns at least one character</li>
<li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.alphanumeric0.html"><code>alphanumeric0</code></a>: Recognizes zero or more numerical and alphabetic characters: <code>/[0-9a-zA-Z]/</code>. <a href="https://docs.rs/nom/latest/nom/character/complete/fn.alphanumeric1.html"><code>alphanumeric1</code></a> does the same but returns at least one character</li>
<li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.digit0.html"><code>digit0</code></a>: Recognizes zero or more numerical characters: <code>/[0-9]/</code>. <a href="https://docs.rs/nom/latest/nom/character/complete/fn.digit1.html"><code>digit1</code></a> does the same but returns at least one character</li>
<li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.multispace0.html"><code>multispace0</code></a>: Recognizes zero or more spaces, tabs, carriage returns and line feeds. <a href="https://docs.rs/nom/latest/nom/character/complete/fn.multispace1.html"><code>multispace1</code></a> does the same but returns at least one character</li>
<li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.space0.html"><code>space0</code></a>: Recognizes zero or more spaces and tabs. <a href="https://docs.rs/nom/latest/nom/character/complete/fn.space1.html"><code>space1</code></a> does the same but returns at least one character</li>
<li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.line_ending.html"><code>line_ending</code></a>: Recognizes an end of line (both <code>\n</code> and <code>\r\n</code>)</li>
<li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.newline.html"><code>newline</code></a>: Matches a newline character <code>\n</code></li>
<li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.tab.html"><code>tab</code></a>: Matches a tab character <code>\t</code></li>
</ul>
<p>We can use these in</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate nom;
</span><span class="boring">pub use nom::IResult;
</span><span class="boring">use std::error::Error;
</span>pub use nom::character::complete::alpha0;
fn parser(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {
    alpha0(input)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let (remaining, letters) = parser(&quot;abc123&quot;)?;
    assert_eq!(remaining, &quot;123&quot;);
    assert_eq!(letters, &quot;abc&quot;);
    
<span class="boring">  Ok(())
</span>}
</code></pre></pre>
<p>One important note is that, due to the type signature of these functions,
it is generally best to use them within a function that returns an <code>IResult</code>.</p>
<p>If you don't, some of the information around the type of the <code>tag</code> function must be
manually specified, which can lead to verbose code or confusing errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-alternatives-and-composition"><a class="header" href="#chapter-3-alternatives-and-composition">Chapter 3: Alternatives and Composition</a></h1>
<p>In the last chapter, we saw how to create simple parsers using the <code>tag</code> function;
and some of Nom's prebuilt parsers.</p>
<p>In this chapter, we explore two other widely used features of Nom:
alternatives and composition.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>Sometimes, we might want to choose between two parsers; and we're happy with
either being used.</p>
<p>Nom gives us a similar ability through the <code>alt()</code> combinator.</p>
<pre><code class="language-rust ignore">use nom::branch::alt;
</code></pre>
<p>The <code>alt()</code> combinator will execute each parser in a tuple until it finds one
that does not error. If all error, then by default you are given the error from 
the last error.</p>
<p>We can see a basic example of <code>alt()</code> below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate nom;
</span>use nom::branch::alt;
use nom::bytes::complete::tag;
use nom::IResult;
<span class="boring">use std::error::Error;
</span>
fn parse_abc_or_def(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {
    alt((
        tag(&quot;abc&quot;),
        tag(&quot;def&quot;)
    ))(input)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let (leftover_input, output) = parse_abc_or_def(&quot;abcWorld&quot;)?;
    assert_eq!(leftover_input, &quot;World&quot;);
    assert_eq!(output, &quot;abc&quot;);

    assert!(parse_abc_or_def(&quot;ghiWorld&quot;).is_err());
<span class="boring">  Ok(())
</span>}
</code></pre></pre>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Now that we can create more interesting regexes, we can compose them together.
The simplest way to do this is just to evaluate them in sequence:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate nom;
</span>use nom::branch::alt;
use nom::bytes::complete::tag;
use nom::IResult;
<span class="boring">use std::error::Error;
</span>
fn parse_abc(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {
    tag(&quot;abc&quot;)(input)
}
fn parse_def_or_ghi(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {
    alt((
        tag(&quot;def&quot;),
        tag(&quot;ghi&quot;)
    ))(input)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let input = &quot;abcghi&quot;;
    let (remainder, abc) = parse_abc(input)?;
    let (remainder, def_or_ghi) = parse_def_or_ghi(remainder)?;
    println!(&quot;first parsed: {abc}; then parsed: {def_or_ghi};&quot;);
    
<span class="boring">  Ok(())
</span>}
</code></pre></pre>
<p>Composing tags is such a common requirement that, in fact, Nom has a few built in
combinators to do it. The simplest of these is <code>tuple()</code>. The <code>tuple()</code> combinator takes a tuple of parsers,
and either returns <code>Ok</code> with a tuple of all of their successful parses, or it 
returns the <code>Err</code> of the first failed parser.</p>
<pre><code class="language-rust ignore">use nom::sequence::tuple;
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate nom;
</span>use nom::branch::alt;
use nom::sequence::tuple;
use nom::bytes::complete::tag_no_case;
use nom::character::complete::{digit1};
use nom::IResult;
<span class="boring">use std::error::Error;
</span>
fn parse_base(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {
    alt((
        tag_no_case(&quot;a&quot;),
        tag_no_case(&quot;t&quot;),
        tag_no_case(&quot;c&quot;),
        tag_no_case(&quot;g&quot;)
    ))(input)
}

fn parse_pair(input: &amp;str) -&gt; IResult&lt;&amp;str, (&amp;str, &amp;str)&gt; {
    // the many_m_n combinator might also be appropriate here.
    tuple((
        parse_base,
        parse_base,
    ))(input)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let (remaining, parsed) = parse_pair(&quot;aTcG&quot;)?;
    assert_eq!(parsed, (&quot;a&quot;, &quot;T&quot;));
    assert_eq!(remaining, &quot;cG&quot;);
 
    assert!(parse_pair(&quot;Dct&quot;).is_err());

<span class="boring">  Ok(())
</span>}
</code></pre></pre>
<h2 id="extra-nom-tools"><a class="header" href="#extra-nom-tools">Extra Nom Tools</a></h2>
<p>After using <code>alt()</code> and <code>tuple()</code>, you might also be interested in a few other parsers that do similar things:</p>
<table><thead><tr><th>combinator</th><th>usage</th><th>input</th><th>output</th><th>comment</th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/nom/latest/nom/sequence/fn.delimited.html">delimited</a></td><td><code>delimited(char('('), take(2), char(')'))</code></td><td><code>&quot;(ab)cd&quot;</code></td><td><code>Ok((&quot;cd&quot;, &quot;ab&quot;))</code></td><td></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/sequence/fn.preceded.html">preceded</a></td><td><code>preceded(tag(&quot;ab&quot;), tag(&quot;XY&quot;))</code></td><td><code>&quot;abXYZ&quot;</code></td><td><code>Ok((&quot;Z&quot;, &quot;XY&quot;))</code></td><td></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/sequence/fn.terminated.html">terminated</a></td><td><code>terminated(tag(&quot;ab&quot;), tag(&quot;XY&quot;))</code></td><td><code>&quot;abXYZ&quot;</code></td><td><code>Ok((&quot;Z&quot;, &quot;ab&quot;))</code></td><td></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/sequence/fn.pair.html">pair</a></td><td><code>pair(tag(&quot;ab&quot;), tag(&quot;XY&quot;))</code></td><td><code>&quot;abXYZ&quot;</code></td><td><code>Ok((&quot;Z&quot;, (&quot;ab&quot;, &quot;XY&quot;)))</code></td><td></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/sequence/fn.separated_pair.html">separated_pair</a></td><td><code>separated_pair(tag(&quot;hello&quot;), char(','), tag(&quot;world&quot;))</code></td><td><code>&quot;hello,world!&quot;</code></td><td><code>Ok((&quot;!&quot;, (&quot;hello&quot;, &quot;world&quot;)))</code></td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-parsers-with-custom-return-types"><a class="header" href="#chapter-4-parsers-with-custom-return-types">Chapter 4: Parsers With Custom Return Types</a></h1>
<p>So far, we have seen mostly functions that take an <code>&amp;str</code>, and return a
<code>IResult&lt;&amp;str, &amp;str&gt;</code>. Splitting strings into smaller strings is certainly useful,
but it's not the only thing Nom is capable of!</p>
<p>A useful operation when parsing is to convert between types; for example
parsing from <code>&amp;str</code> to another primitive, like <code>bool</code>.</p>
<p>All we need to do for our parser to return a different type is to change
the second type parameter of <code>IResult</code> to the desired return type.
For example, to return a bool, return a <code>IResult&lt;&amp;str, bool&gt;</code>.</p>
<p>Recall that the first type parameter of the <code>IResult</code> is the input
type, so even if you're returning something different, if your input
is a <code>&amp;str</code>, the first type argument of <code>IResult</code> should be also.</p>
<p>Until you have read the chapter on Errors, we strongly suggest avoiding
the use of parsers built into Rust (like <code>str.parse</code>); as they require
special handling to work well with Nom.</p>
<p>That said, one Nom-native way of doing a type conversion is to use the
<a href="https://docs.rs/nom/latest/nom/combinator/fn.value.html"><code>value</code></a> combinator
to convert from a successful parse to a particular value.</p>
<p>The following code converts from a string containing <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>,
to the corresponding <code>bool</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate nom;
</span><span class="boring">use std::error::Error;
</span>use nom::IResult;
use nom::bytes::complete::tag;
use nom::combinator::value;
use nom::branch::alt;

fn parse_bool(input: &amp;str) -&gt; IResult&lt;&amp;str, bool&gt; {
    // either, parse `&quot;true&quot;` -&gt; `true`; `&quot;false&quot;` -&gt; `false`, or error.
    alt((
      value(true, tag(&quot;true&quot;)),
      value(false, tag(&quot;false&quot;)),
    ))(input)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // Parses the `&quot;true&quot;` out.
    let (remaining, parsed) = parse_bool(&quot;true|false&quot;)?;
    assert_eq!(parsed, true);
    assert_eq!(remaining, &quot;|false&quot;);
   
    // If we forget about the &quot;|&quot;, we get an error.
    let parsing_error = parse_bool(remaining);
    assert!(parsing_error.is_err());
    
    // Skipping the first byte gives us `false`!
    let (remaining, parsed) = parse_bool(&amp;remaining[1..])?;
    assert_eq!(parsed, false);
    assert_eq!(remaining, &quot;&quot;);
    
    

<span class="boring">  Ok(())
</span>}
</code></pre></pre>
<h2 id="noms-in-built-parser-functions"><a class="header" href="#noms-in-built-parser-functions">Nom's in-built parser functions</a></h2>
<p>Nom has a wide array of parsers built in. Here is a list of
<a href="https://docs.rs/nom/latest/nom/character/complete/index.html">parsers which recognize specific characters</a>.</p>
<p>Some of them we have seen before in Chapter 2, but now we also can try out the parsers that return different
types, like <code>i32</code>. An example of this parser is shown in the next section.</p>
<h2 id="building-a-more-complex-example"><a class="header" href="#building-a-more-complex-example">Building a More Complex Example</a></h2>
<p>A more complex example of parsing custom types might be parsing a 2D coordinate.</p>
<p>Let us try to figure out how to design this.</p>
<ul>
<li>We know that we want to take a string, like <code>&quot;(3, -2)&quot;</code>, and convert into
a <code>Coordinate</code> struct.</li>
<li>We can split this into three parts:</li>
</ul>
<pre><code class="language-ignore">(vvvvvvvvvvvvv) # The outer brackets.
  vvvv , vvvv   # The comma, separating values.
    3     -2    # The actual integers.
</code></pre>
<ul>
<li>
<p>So, we will need three parsers, to deal with this:</p>
<ol>
<li>A parser for integers, which  will deal with the raw numbers.</li>
<li>A parser for comma seperated pair, which will split it up into integers.</li>
<li>A parser for the outer brackets.</li>
</ol>
</li>
<li>
<p>We can see below how we achieve this:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate nom;
</span><span class="boring">use std::error::Error;
</span>use nom::IResult;
use nom::bytes::complete::tag;
use nom::sequence::{separated_pair, delimited};

// This is the type we will parse into.
#[derive(Debug,PartialEq)]
pub struct Coordinate {
  pub x:   i32,
  pub y:   i32,
}

// 1. Nom has an in-built i32 parser.
use nom::character::complete::i32;

// 2. Use the `separated_pair` parser to combine two parsers (in this case,
//    both `i32`), ignoring something in-between.
fn parse_integer_pair(input: &amp;str) -&gt; IResult&lt;&amp;str, (i32, i32)&gt; {
    separated_pair(
        i32,
        tag(&quot;, &quot;),
        i32
    )(input)
}

// 3. Use the `delimited` parser to apply a parser, ignoring the results
//    of two surrounding parsers.
fn parse_coordinate(input: &amp;str) -&gt; IResult&lt;&amp;str, Coordinate&gt; {
    let (remaining, (x, y)) = delimited(
        tag(&quot;(&quot;),
        parse_integer_pair,
        tag(&quot;)&quot;)
    )(input)?;
    
    // Note: we could construct this by implementing `From` on `Coordinate`,
    // We don't, just so it's obvious what's happening.
    Ok((remaining, Coordinate {x, y}))
    
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let (_, parsed) = parse_coordinate(&quot;(3, 5)&quot;)?;
    assert_eq!(parsed, Coordinate {x: 3, y: 5});
   
    let (_, parsed) = parse_coordinate(&quot;(2, -4)&quot;)?;
    assert_eq!(parsed, Coordinate {x: 2, y: -4});
    
    let parsing_error = parse_coordinate(&quot;(3,)&quot;);
    assert!(parsing_error.is_err());
    
    let parsing_error = parse_coordinate(&quot;(,3)&quot;);
    assert!(parsing_error.is_err());
    
    let parsing_error = parse_coordinate(&quot;Ferris&quot;);
    assert!(parsing_error.is_err());
    

<span class="boring">  Ok(())
</span>}
</code></pre></pre>
<p>As an exercise, you might want to explore how to make this parser deal gracefully with 
whitespace in the input. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5-repeating-with-predicates"><a class="header" href="#chapter-5-repeating-with-predicates">Chapter 5: Repeating with Predicates</a></h1>
<p>Just as, when programming, the humble while loop unlocks many useful
features; in Nom, repeating a parser multiple times can be incredibly useful</p>
<p>There are, however, two ways of including repeating functionality into Nom --
parsers which are governed by a predicate; and combinators which repeat
a parser.</p>
<h2 id="parsers-which-use-a-predicate"><a class="header" href="#parsers-which-use-a-predicate">Parsers which use a predicate</a></h2>
<p>A <code>predicate</code> is a function which returns a boolean value (i.e. given some input,
it returns <code>true</code> or <code>false</code>). These are incredibly common when parsing -- for instance,
a predicate <code>is_vowel</code> might decide whether a character is an english vowel (a, e, i, o or u).</p>
<p>These can be used to make parsers that Nom hasn't built in. For instance, the below
parser will take as many vowels as possible.</p>
<p>There are a few different categories of predicate parsers that are worth mentioning:</p>
<ul>
<li>For bytes, there are three different categories of parser: <code>take_till</code>, <code>take_until</code>, and <code>take_while</code>.
<code>take_till</code> will continue consuming input until its input meets the predicate.
<code>take_while</code> will continue consuming input until its input <em>does not</em> meet the predicate.
<code>take_until</code> looks a lot like a predicate parser, but simply consumes until the first
occurence of the pattern of bytes.</li>
<li>Some parsers have a &quot;twin&quot; with a <code>1</code> at the end of their name -- for example, <code>take_while</code>
has <code>take_while1</code>. The difference between them is that <code>take_while</code> could return an empty
slice if the first byte does not satisfy a predicate. <code>take_while1</code> returns an error if
the predicate is not met.</li>
<li>As a special case, <code>take_while_m_n</code> is like <code>take_while</code>, but guarantees that it will consume
at least <code>m</code> bytes, and no more than <code>n</code> bytes.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate nom;
</span><span class="boring">use std::error::Error;
</span>use nom::IResult;
use nom::bytes::complete::{tag, take_until, take_while};
use nom::character::{is_space};
use nom::sequence::{terminated};

fn parse_sentence(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {
    terminated(take_until(&quot;.&quot;), take_while(|c| c == '.' || c == ' '))(input)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let (remaining, parsed) = parse_sentence(&quot;I am Tom. I write Rust.&quot;)?;
    assert_eq!(parsed, &quot;I am Tom&quot;);
    assert_eq!(remaining, &quot;I write Rust.&quot;);
   
    let parsing_error = parse_sentence(&quot;Not a sentence (no period at the end)&quot;);
    assert!(parsing_error.is_err());
    

<span class="boring">  Ok(())
</span>}
</code></pre></pre>
<p>For detailed examples, see their documentation, shown below:</p>
<table><thead><tr><th>combinator</th><th>usage</th><th>input</th><th>output</th><th>comment</th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_while.html">take_while</a></td><td><code>take_while(is_alphabetic)</code></td><td><code>&quot;abc123&quot;</code></td><td><code>Ok((&quot;123&quot;, &quot;abc&quot;))</code></td><td>Returns the longest list of bytes for which the provided function returns true. <code>take_while1</code> does the same, but must return at least one character. <code>take_while_m_n</code> does the same, but must return between <code>m</code> and <code>n</code> characters.</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_till.html">take_till</a></td><td><code>take_till(is_alphabetic)</code></td><td><code>&quot;123abc&quot;</code></td><td><code>Ok((&quot;abc&quot;, &quot;123&quot;))</code></td><td>Returns the longest list of bytes or characters until the provided function returns true. <code>take_till1</code> does the same, but must return at least one character. This is the reverse behaviour from <code>take_while</code>: <code>take_till(f)</code> is equivalent to <code>take_while(\|c\| !f(c))</code></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_until.html">take_until</a></td><td><code>take_until(&quot;world&quot;)</code></td><td><code>&quot;Hello world&quot;</code></td><td><code>Ok((&quot;world&quot;, &quot;Hello &quot;))</code></td><td>Returns the longest list of bytes or characters until the provided tag is found. <code>take_until1</code> does the same, but must return at least one character</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6-repeating-parsers"><a class="header" href="#chapter-6-repeating-parsers">Chapter 6: Repeating Parsers</a></h1>
<p>A single parser which repeats a predicate is useful, but more useful still is a combinator that
repeats a parser. Nom has multiple combinators which operate on this principle; the most obvious of
which is <code>many0</code>, which applies a parser as many times as possible; and returns a vector of
the results of those parses. Here is an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate nom;
</span><span class="boring">use std::error::Error;
</span>use nom::IResult;
use nom::multi::many0;
use nom::bytes::complete::tag;

fn parser(s: &amp;str) -&gt; IResult&lt;&amp;str, Vec&lt;&amp;str&gt;&gt; {
  many0(tag(&quot;abc&quot;))(s)
}

fn main() {
    assert_eq!(parser(&quot;abcabc&quot;), Ok((&quot;&quot;, vec![&quot;abc&quot;, &quot;abc&quot;])));
    assert_eq!(parser(&quot;abc123&quot;), Ok((&quot;123&quot;, vec![&quot;abc&quot;])));
    assert_eq!(parser(&quot;123123&quot;), Ok((&quot;123123&quot;, vec![])));
    assert_eq!(parser(&quot;&quot;), Ok((&quot;&quot;, vec![])));
}
</code></pre></pre>
<p>There are many different parsers to choose from:</p>
<table><thead><tr><th>combinator</th><th>usage</th><th>input</th><th>output</th><th>comment</th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/nom/latest/nom/multi/fn.count.html">count</a></td><td><code>count(take(2), 3)</code></td><td><code>&quot;abcdefgh&quot;</code></td><td><code>Ok((&quot;gh&quot;, vec![&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]))</code></td><td>Applies the child parser a specified number of times</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/multi/fn.many0.html">many0</a></td><td><code>many0(tag(&quot;ab&quot;))</code></td><td><code>&quot;abababc&quot;</code></td><td><code>Ok((&quot;c&quot;, vec![&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]))</code></td><td>Applies the parser 0 or more times and returns the list of results in a Vec. <code>many1</code> does the same operation but must return at least one element</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/multi/fn.many_m_n.html">many_m_n</a></td><td><code>many_m_n(1, 3, tag(&quot;ab&quot;))</code></td><td><code>&quot;ababc&quot;</code></td><td><code>Ok((&quot;c&quot;, vec![&quot;ab&quot;, &quot;ab&quot;]))</code></td><td>Applies the parser between m and n times (n included) and returns the list of results in a Vec</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/multi/fn.many_till.html">many_till</a></td><td><code>many_till(tag( &quot;ab&quot; ), tag( &quot;ef&quot; ))</code></td><td><code>&quot;ababefg&quot;</code></td><td><code>Ok((&quot;g&quot;, (vec![&quot;ab&quot;, &quot;ab&quot;], &quot;ef&quot;)))</code></td><td>Applies the first parser until the second applies. Returns a tuple containing the list of results from the first in a Vec and the result of the second</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/multi/fn.separated_list0.html">separated_list0</a></td><td><code>separated_list0(tag(&quot;,&quot;), tag(&quot;ab&quot;))</code></td><td><code>&quot;ab,ab,ab.&quot;</code></td><td><code>Ok((&quot;.&quot;, vec![&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]))</code></td><td><code>separated_list1</code> works like <code>separated_list0</code> but must returns at least one element</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/multi/fn.fold_many0.html">fold_many0</a></td><td><code>fold_many0(be_u8, \|\| 0, \|acc, item\| acc + item)</code></td><td><code>[1, 2, 3]</code></td><td><code>Ok(([], 6))</code></td><td>Applies the parser 0 or more times and folds the list of return values. The <code>fold_many1</code> version must apply the child parser at least one time</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/multi/fn.fold_many_m_n.html">fold_many_m_n</a></td><td><code>fold_many_m_n(1, 2, be_u8, \|\| 0, \|acc, item\| acc + item)</code></td><td><code>[1, 2, 3]</code></td><td><code>Ok(([3], 3))</code></td><td>Applies the parser between m and n times (n included) and folds the list of return value</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/multi/fn.length_count.html">length_count</a></td><td><code>length_count(number, tag(&quot;ab&quot;))</code></td><td><code>&quot;2ababab&quot;</code></td><td><code>Ok((&quot;ab&quot;, vec![&quot;ab&quot;, &quot;ab&quot;]))</code></td><td>Gets a number from the first parser, then applies the second parser that many times</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7-using-errors-from-outside-nom"><a class="header" href="#chapter-7-using-errors-from-outside-nom">Chapter 7: Using Errors from Outside Nom</a></h1>
<p><a href="https://github.com/Geal/nom/blob/main/doc/error_management.md">Nom has other documentation about errors, so in place of this chapter, read this page.</a></p>
<h2 id="particular-notes"><a class="header" href="#particular-notes">Particular Notes</a></h2>
<ul>
<li>It's particularly useful to use the <code>map_res</code> function. It allows you to
convert an external error to a Nom error. For an example,
see <a href="https://github.com/Geal/nom#example">the Nom example on the front page</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to-be-completed"><a class="header" href="#to-be-completed">To Be Completed</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to-be-completed-1"><a class="header" href="#to-be-completed-1">To Be Completed</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to-be-completed-2"><a class="header" href="#to-be-completed-2">To Be Completed</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
